use std::net::SocketAddr;
use tokio::sync::mpsc;

/// Events that can be generated by the protocol system
#[derive(Debug, Clone)]
pub enum ProtocolEvent {
    /// A peer has successfully connected
    PeerConnected {
        peer_key: [u8; 32],
        endpoint: SocketAddr,
    },
    /// A peer has disconnected
    PeerDisconnected {
        peer_key: [u8; 32],
    },
    /// A peer's endpoint has changed
    PeerEndpointChanged {
        peer_key: [u8; 32],
        old_endpoint: Option<SocketAddr>,
        new_endpoint: SocketAddr,
    },
    /// Connection to a peer has become stale
    PeerConnectionStale {
        peer_key: [u8; 32],
    },
    /// Hole punching has been initiated
    HolePunchInitiated {
        peer_a: [u8; 32],
        peer_b: [u8; 32],
        punch_id: [u8; 16],
    },
    /// Hole punching has completed (successfully or not)
    HolePunchCompleted {
        punch_id: [u8; 16],
        success: bool,
    },
    /// A new peer has been discovered
    PeerDiscovered {
        peer_key: [u8; 32],
        endpoint: SocketAddr,
        discovered_through: [u8; 32], // Anchor that provided the info
    },
}

/// Event system for protocol notifications
#[derive(Clone)]
pub struct EventSystem {
    sender: mpsc::UnboundedSender<ProtocolEvent>,
}

impl EventSystem {
    pub fn new() -> (Self, mpsc::UnboundedReceiver<ProtocolEvent>) {
        let (sender, receiver) = mpsc::unbounded_channel();
        (Self { sender }, receiver)
    }

    /// Emit a protocol event
    pub fn emit(&self, event: ProtocolEvent) {
        if let Err(e) = self.sender.send(event) {
            eprintln!("Failed to emit protocol event: {}", e);
        }
    }

    /// Emit a peer connected event
    pub fn peer_connected(&self, peer_key: [u8; 32], endpoint: SocketAddr) {
        self.emit(ProtocolEvent::PeerConnected { peer_key, endpoint });
    }

    /// Emit a peer disconnected event
    pub fn peer_disconnected(&self, peer_key: [u8; 32]) {
        self.emit(ProtocolEvent::PeerDisconnected { peer_key });
    }

    /// Emit a peer endpoint changed event
    pub fn peer_endpoint_changed(&self, peer_key: [u8; 32], old_endpoint: Option<SocketAddr>, new_endpoint: SocketAddr) {
        self.emit(ProtocolEvent::PeerEndpointChanged {
            peer_key,
            old_endpoint,
            new_endpoint,
        });
    }

    /// Emit a peer connection stale event
    pub fn peer_connection_stale(&self, peer_key: [u8; 32]) {
        self.emit(ProtocolEvent::PeerConnectionStale { peer_key });
    }

    /// Emit a hole punch initiated event
    pub fn hole_punch_initiated(&self, peer_a: [u8; 32], peer_b: [u8; 32], punch_id: [u8; 16]) {
        self.emit(ProtocolEvent::HolePunchInitiated {
            peer_a,
            peer_b,
            punch_id,
        });
    }

    /// Emit a hole punch completed event
    pub fn hole_punch_completed(&self, punch_id: [u8; 16], success: bool) {
        self.emit(ProtocolEvent::HolePunchCompleted { punch_id, success });
    }

    /// Emit a peer discovered event
    pub fn peer_discovered(&self, peer_key: [u8; 32], endpoint: SocketAddr, discovered_through: [u8; 32]) {
        self.emit(ProtocolEvent::PeerDiscovered {
            peer_key,
            endpoint,
            discovered_through,
        });
    }
}

/// Event handler for processing protocol events
pub struct EventHandler;

impl EventHandler {
    /// Process a protocol event
    pub async fn handle_event(event: ProtocolEvent) {
        match event {
            ProtocolEvent::PeerConnected { peer_key, endpoint } => {
                println!("üîó Peer connected: {:?} at {}", peer_key, endpoint);
            }
            ProtocolEvent::PeerDisconnected { peer_key } => {
                println!("üíî Peer disconnected: {:?}", peer_key);
            }
            ProtocolEvent::PeerEndpointChanged { peer_key, old_endpoint, new_endpoint } => {
                println!(
                    "üîÑ Peer {:?} endpoint changed: {:?} -> {}",
                    peer_key, old_endpoint, new_endpoint
                );
            }
            ProtocolEvent::PeerConnectionStale { peer_key } => {
                println!("‚ö†Ô∏è  Peer connection stale: {:?}", peer_key);
            }
            ProtocolEvent::HolePunchInitiated { peer_a, peer_b, punch_id } => {
                println!(
                    "ü•ä Hole punching initiated between {:?} and {:?} (ID: {:?})",
                    peer_a, peer_b, punch_id
                );
            }
            ProtocolEvent::HolePunchCompleted { punch_id, success } => {
                let status = if success { "‚úÖ" } else { "‚ùå" };
                println!("{} Hole punching completed (ID: {:?})", status, punch_id);
            }
            ProtocolEvent::PeerDiscovered { peer_key, endpoint, discovered_through } => {
                println!(
                    "üîç Peer discovered: {:?} at {} (via {:?})",
                    peer_key, endpoint, discovered_through
                );
            }
        }
    }

    /// Start event processing loop
    pub async fn start_event_loop(mut receiver: mpsc::UnboundedReceiver<ProtocolEvent>) {
        tokio::spawn(async move {
            while let Some(event) = receiver.recv().await {
                Self::handle_event(event).await;
            }
        });
    }
}