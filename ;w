use chacha20poly1305::{ChaCha20Poly1305, KeyInit};
use ipou::cli::commands::{handle_gen_key, handle_pub_key};
use ipou::{Config, Peer, RuntimeConfig};
use std::io;
use std::sync::Arc;
use std::{
    collections::HashMap,
    net::{IpAddr, Ipv4Addr, SocketAddr},
};

use clap::{Parser, Subcommand};
use ipou::error::Result;
use tokio::net::UdpSocket;
use tokio::sync::mpsc;
use x25519_dalek::{EphemeralSecret, PublicKey, StaticSecret};
// Constants
const MTU: usize = 1420;
const CHANNEL_BUFFER_SIZE: usize = MTU + 512; // Buffered channels
const ENCRYPTION_OVERHEAD: usize = 28; // 12 nonce + 16 auth tag

#[tokio::main]
async fn main() -> Result<()> {
    let cli = ipou::cli::Cli::parse();
    // Subcommands
    match &cli.command {
        Some(ipou::cli::Commands::Genkey {}) => handle_gen_key(),
        Some(ipou::cli::Commands::Pubkey {}) => handle_pub_key(),
        None => Ok(()),
    };

    // Load config file
    let config_path = "config.yaml";
    let conf: Config = match std::fs::read_to_string(config_path) {
        Ok(content) => serde_yml::from_str(&content).unwrap(),
        Err(_) => {
            eprintln!("No config file found! using defaults.");
            let (private_key, public_key) = ipou::crypto::generate_keypair();

            let peers: HashMap<IpAddr, Peer> = HashMap::new();

            let conf = Config {
                name: "utun0".to_string(),
                address: "10.0.0.1".to_string(),
                secret: base64::encode(private_key),
                pubkey: base64::encode(public_key),
                port: 1194,
                peers,
            };
            std::fs::write(config_path, serde_yml::to_string(&conf).unwrap())
                .expect("Failed to write default config file");
            conf
        }
    };
    let config = Arc::new(conf);

    let config_clone = Arc::clone(&config);
    // Initialize once after config load
    let mut shared_secrets = HashMap::new();
    let mut ciphers = HashMap::new();

    let mut secret_bytes = [0u8; 32];
    base64::decode_config_slice(&config.secret, base64::STANDARD, &mut secret_bytes).unwrap();
    let static_secret = StaticSecret::from(secret_bytes);

    let mut ips = HashMap::new();
    for (ip, peer) in &config.peers {
        let mut pub_key_bytes = [0u8; 32];
        base64::decode_config_slice(&peer.pub_key, base64::STANDARD, &mut pub_key_bytes).unwrap();
        let pub_key = PublicKey::from(pub_key_bytes);
        let shared_secret = static_secret.diffie_hellman(&pub_key);
        let cipher = ChaCha20Poly1305::new(shared_secret.as_bytes().into());
        shared_secrets.insert(*ip, *shared_secret.as_bytes());
        ciphers.insert(*ip, cipher);
        ips.insert(peer.sock_addr, *ip);
    }

    let runtime_config = Arc::new(RuntimeConfig {
        shared_secrets,
        ciphers,
        ips,
    });

    let mut tun_config = tun::Configuration::default();
    tun_config
        .tun_name(&config_clone.name)
        .address(config_clone.address.parse::<Ipv4Addr>().unwrap())
        .netmask((255, 255, 255, 0))
        .mtu(MTU as u16)
        .up();

    let dev = tun::create_as_async(&tun_config)
        .await
        .expect("Failed to create TUN device");
    let sock = UdpSocket::bind(format!("0.0.0.0:{}", Arc::clone(&config).port)).await?;
    println!("UDP socket bound to: {}", sock.local_addr()?);

    // Create channel for sending decrypted packets to TUN device
    let (tx, mut rx) = mpsc::channel::<Vec<u8>>(CHANNEL_BUFFER_SIZE);
    // Create channel for sending encrypted packets to UDP socket
    let (utx, mut urx) = mpsc::channel::<(Vec<u8>, SocketAddr)>(CHANNEL_BUFFER_SIZE);

    // Pre-allocate buffers to avoid repeated allocations
    let mut udp_buf = [0u8; MTU + 512];
    let mut buf = [0u8; MTU];
    let mut packet = Vec::with_capacity(MTU + ENCRYPTION_OVERHEAD);

    loop {
        tokio::select! {

            result = async {
                let recv_result =sock.recv_from(&mut udp_buf).await;
                recv_result.map(|(len,addr)| (udp_buf, len, addr)) } => {
                       if let Ok((udp_buf, len, peer_addr)) = result {
                            let runtime_conf = Arc::clone(&runtime_config);
                           let tx_clone = tx.clone();
                            if len >= 32 { // 12 bytes nonce + 16 bytes auth tag + min 4 bytes data
                                ipou::net::handle_udp_packet(&udp_buf, len, peer_addr, runtime_conf,tx_clone).await
                            }
                       }
        }

               // Receive decrypted packets from channel and send to TUN
               Some(decrypted_packet) = rx.recv() => {
                   match dev.send(&decrypted_packet).await {
                       Ok(_sent) => {},
                       Err(_e) => {},
                   }
               }

               // Receive decrypted packets from channel and send to TUN
               Some((encrypted_packet, peer_addr)) = urx.recv() => {
                   match sock.send_to(&encrypted_packet, peer_addr).await {
                       Ok(_sent) => {},
                       Err(_e) => {},
                   }
               }

                result = async {
                    let recv_result = dev.recv(&mut buf).await;
                    recv_result.map(|len| (buf, len))
                } => {
                       // handle TUN device
                       if let Ok((buf,len)) =  result {
                           let utx_clone = utx.clone();
                            let packet = &mut packet;
                           let conf_clone = Arc::clone(&config);
                            let runtime_conf = Arc::clone(&runtime_config);
                           if len >= 20 {
                              ipou::net::handle_tun_packet(&buf, len, packet,conf_clone, runtime_conf, utx_clone).await
                           }
                       }
                   }
               }
    }
}
